
(*
 ***************************************************************************************
 ***************************************************************************************
 * Student:    Dalle Pezze Piero
 * N.:         486228-sin
 * Course:     Linguaggi di Programmazione
 * University: Padova (Italy)
 * Date:       05/06/2006
 * Title:      Compiler from Lisp to a SECD language (Stack, Environment, Control, Dump)
 ***************************************************************************************
 ***************************************************************************************
 *)





(********************************* LISP COMPILER ************************************)



(*
 ************************************************************************************* 
 * DATATYPES
 *************************************************************************************
 *)

(**
 * This is the type of constants that can be used in a Lisp program. It
 * represents integers, strings, booleans, Nil and s-expressions.
 *)
datatype s_espressione =   NUM of int
		         | STRINGA of string
			 | T | F | NIL
			 | DOT of s_espressione * s_espressione;

(**
 * This is the type of statements and constructs a Lisp program. It
 * represents variables, quote (to not evaluate an expression), 
 * operators (CAR, CDR, ATOM, ADD, SUB, MUL, DIV, REM, EQ, LEQ, CONS), 
 * if-then-else, lambda-expressions, invocations (Call), let,
 * and let recursive.
 *)
datatype Sexpr =   Var of string
		 | Quote of s_espressione
		 | Op of string * Sexpr list
		 | If of Sexpr * Sexpr * Sexpr
	 	 | Lambda of string list * Sexpr
		 | Call of Sexpr * Sexpr list
		 | Let of Sexpr * string list * Sexpr list
		 | Letrec of Sexpr * string list * Sexpr list;

(**
 * It represents a SECD program. On details, it can be an unary operation
 * among ADD, SUB, MUL, DIV, REM, EQ, LEQ, CAR, CDR, CONS, ATOM, JOIN, RTN, AP,
 * RAP, DUM and STOP, an instruction to load (LD) a value in the position (n1,n2) 
 * of the environment E on the stack S, an instruction to load an expression 
 * without evaluate it (LDC), the if-then-else statement (SEL), an instruction to
 * load a function in the stack S (LDF). 
 *)
datatype secdexpr =   ADD | SUB | MUL | DIV | REM | EQ | LEQ | CAR | CDR | 
		      CONS | ATOM | JOIN | RTN | AP | RAP | DUM | STOP
		    | LD of int * int
		    | LDC of s_espressione
		    | SEL of secdexpr list * secdexpr list
		    | LDF of secdexpr list;



(*
 ************************************************************************************* 
 * EXCEPTIONS 
 *************************************************************************************
 *)

(**
 * The string is the message of the exception.
 *)
exception Error of string;


(*
 ************************************************************************************* 
 * FUNCTIONS 
 *************************************************************************************
 *)


(**
 * This function searches and returns the coordinates of the value x as a 
 * tuple (k, h) that is its position into the list of lists y::z. This 
 * function must be invoked by passing the value 0 to the formal parameter k.
 *
 * - Parameters: x,    a string value to find in y::z,
 *		 k,    the counter, initially it is 0,
 * 		 y::z, a string list list.
 * - Returns:	 the coordinates of the value x.
 * - Exceptions: value not found, if it receives an empty list as third parameter
 *		                  or if it do not find x.
 *)
fun   location(x : string, k, [] : string list list) = raise Error("Error in location: value not found")
    | location(x : string, k, y::z : string list list) : int * int= 
	let 
	   fun   findPosition(x, h, nil) = ~1
    	       | findPosition(x, h, y::z) = if(x = y) then h else findPosition(x, h+1, z)
	   val h = findPosition(x, 0, y)
	in 
	   if(h <> ~1) then (k, h) else location(x, k+1, z)
	end;


(**
 * This recursive function is a compiler from a pure Lisp language to the SEDC language. 
 * The Lisp language, here used, is in a simple form. On details, it is the output of 
 * the sintax analysis. So this function provides to generate a first code for an
 * abstract machine SECD.
 *
 * Parameters: lispProgram, a lisp program written in a simple form to translate
 *	 		    in a SECD language,
 *             namesList,   a list of lists of names that can occur free in e,
 *	       code,        the SECD code generated (at start it is []).
 * Returns:    The SECD code generated by translating the lisp program into the SECD language.
 * Exception:  value not found,    if the lispProgram contains a variable that not exist in the 
 *				   namesList or an operator is ill-formed,
 *             undefined operator, if the lispProgram contains an operand not defined.
 *)
fun COMP(lispProgram: Sexpr, namesList: string list list, code: secdexpr list): secdexpr list =

    case lispProgram of

     	Var x => LD(location(x, 0, namesList))::code

     |  Quote k => LDC(k)::code
	
     |  Op(operator, operandList) =>
 	    (case operator of
		"ADD"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (ADD::code)))
	     |  "SUB"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (SUB::code)))
	     |  "MUL"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (MUL::code)))
	     |  "DIV"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (DIV::code)))
	     |  "REM"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (REM::code)))
	     |  "EQ"   => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (EQ::code)))
	     |  "LEQ"  => COMP(hd(operandList), namesList, COMP(hd(tl(operandList)), namesList, (LEQ::code)))
	     |  "CAR"  => COMP(hd(operandList), namesList, (CAR::code))
	     |  "CDR"  => COMP(hd(operandList), namesList, (CDR::code))
	     |  "ATOM" => COMP(hd(operandList), namesList, (ATOM::code))
	     |  "CONS" => COMP(hd(tl(operandList)), namesList, COMP(hd(operandList), namesList, (CONS::code)))
	     |  _ => raise Error("Error in COMP: undefined operator")
	     )

     |  If(cond, thenExpr, elseExpr) =>
	     let
		val thenpt = COMP(thenExpr, namesList, [JOIN])
		val elsept = COMP(elseExpr, namesList, [JOIN])
	     in
		COMP(cond, namesList, SEL(thenpt, elsept)::code)
	     end

     |  Lambda(boundedVars, body) => LDF(COMP(body, boundedVars::namesList, [RTN]))::code

     |  Call(lambdaExpr, actualParamList) =>
	     let
		fun   ldParams(x::y) = ldParams(y)@COMP(x, namesList, [])@[CONS]
		    | ldParams([]) = [];
	     in
		LDC(NIL)::ldParams(actualParamList)@COMP(lambdaExpr, namesList, [])@AP::code
	     end

     |  Let(body, localVarsList, initExprList) => 
	     let
		fun   ldExpr(x::y) = ldExpr(y)@COMP(x, namesList, [])@[CONS]
		    | ldExpr([]) = [];
	     in
	 	LDC(NIL)::ldExpr(initExprList)@LDF(COMP(body, localVarsList::namesList, [RTN]))::AP::code
	     end

     |  Letrec(body, localVarsList, lambdaAbstrList) => 
	     let
		val m = localVarsList::namesList
		fun   ldAbstr(x::y) = ldAbstr(y)@COMP(x, m, [])@[CONS]
		    | ldAbstr([]) = [];
	     in
	 	DUM::LDC(NIL)::ldAbstr(lambdaAbstrList)@LDF(COMP(body, m, [RTN]))::RAP::code
	     end;






(* This function calls the function COMP and handles its exception *)
fun startCOMP(lispProgram: Sexpr, namesList: string list list, code: secdexpr list): secdexpr list = 
	 COMP(lispProgram, namesList, code) handle Error(a) =>  (print(a); [STOP]);